{"posts":[{"title":"Nginx配置vue项目","text":"1、Nginx 配置 HTTP/21.1 环境要求 Nginx 版本：需要 1.9.5 或以上。 SSL 支持：HTTP/2 仅支持 HTTPS，所以必须启用 SSL（证书、私钥必须配置）。 OpenSSL 版本：使用 1.0.2 及以上版本。 1.2 示例配置在 Nginx 配置文件（例如 /etc/nginx/conf.d/your-domain.conf）中配置一个 HTTPS 站点并启用 HTTP/2： 123456789101112131415server { listen 443 ssl http2; server_name yourdomain.com; ssl_certificate /path/to/your_certificate.crt; ssl_certificate_key /path/to/your_certificate.key; # 处理静态资源或反向代理请求 location / { # 例如反向代理到后端服务 proxy_pass http://127.0.0.1:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; }} 2. 托管 Vue 项目2.1 背景当使用 Vue Router 的 History 模式时，前端路由由客户端接管。用户刷新或直接访问子路径时，Nginx 需要将请求重定向到 index.html，让 Vue 应用负责路由解析，否则会出现 404 错误。 2.2 示例配置假设你的 Vue 项目构建后的静态文件位于 /var/www/vue-app/dist 目录，配置示例如下： 123456789101112131415161718192021222324252627server { listen 80; server_name vue.example.com; # 指定 Vue 项目的静态文件目录 root /var/www/vue-app/dist; index index.html; # 配置 try_files 规则：先查找请求的文件或目录， # 如果不存在，则返回 index.html 供前端路由处理。 location / { try_files $uri $uri/ /index.html; } # 静态资源缓存优化 location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg)$ { expires 1y; add_header Cache-Control &quot;public, no-transform&quot;; } # 可选：错误页配置 error_page 404 /404.html; location = /404.html { internal; }} 2.3 说明 root：指定静态文件目录（即 Vue 项目打包后的 dist）。 index：定义默认的首页文件。 try_files：依次尝试访问请求的 URI，如果没有找到，则返回 /index.html。这确保了前端路由能够接管所有非静态文件的请求。 3. 完整示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 重定向HTTP到HTTPSserver { listen 80; server_name yourdomain.com; return 301 https://$server_name$request_uri;}# HTTPS &amp; HTTP/2主配置server { listen 443 ssl http2; server_name yourdomain.com; # SSL证书 ssl_certificate /path/to/your_certificate.crt; ssl_certificate_key /path/to/your_certificate.key; # SSL优化 ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers EECDH+CHACHA20:EECDH+AESGCM:EDH+AESGCM; ssl_prefer_server_ciphers on; # 网站根目录 root /var/www/vue-app/dist; index index.html; # 主请求处理 location / { try_files $uri $uri/ /index.html; # 支持Vue Router history模式 add_header X-Frame-Options &quot;SAMEORIGIN&quot;; add_header X-Content-Type-Options &quot;nosniff&quot;; } # 静态资源缓存 location ~* \\.(?:js|css|png|jpg|svg|woff2)$ { expires 365d; access_log off; add_header Cache-Control &quot;public&quot;; } # Gzip压缩 gzip on; gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; gzip_proxied any; gzip_comp_level 6; gzip_min_length 1000;} 4. 验证与部署12345678# 4.1检查Nginx配置 sudo nginx -t# 4.2 重新加载Nginxsudo systemctl reload nginx# 4.3 验证HTTP/2curl -I -L --http2 https://yourdomain.com# 4.4 验证路由回退# 访问https://yourdomain.com/non-existent-path应显示Vue应用页面而非404","link":"/2020/03/Nginx%E9%85%8D%E7%BD%AEvue%E9%A1%B9%E7%9B%AE/"},{"title":"css计数器","text":"需求背景单行显示多个标签(标签宽度不固定), 超出部分隐藏并在最右侧显示剩余数量。 方案一通过js计算 外层容器宽度 - 标签宽度 方案二 css计数器CSS 计数器是一种通过 CSS 自动对元素进行计数和编号的功能，无需依赖 JavaScript 或手动编写序号。它通过 counter-reset、counter-increment 和 counter()/counters() 函数实现动态计数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } .tags-container { display: flex; max-width: 200px; /* 容器最大宽度 */ overflow: hidden; white-space: nowrap; /* 保持单行显示 */ counter-reset: hidden-items; /* 初始化计数器 */ } .tags-wrapper { display: flex; flex: 1; flex-wrap: wrap; overflow: hidden; max-height: 30px; gap: 8px; } .tag { /* 标签基础样式 */ display: inline-block; padding: 4px 12px; background: #e0e0e0; border-radius: 12px; } .tag-hidden { counter-increment: hidden-items; } .remaining-counter { display: inline-block; padding: 4px 12px; background: #d1d1d1; border-radius: 12px; } /* 通过伪元素显示剩余数量 */ .remaining-counter::before { content: &quot;+&quot; counter(hidden-items); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;tags-container&quot;&gt; &lt;div class=&quot;tags-wrapper&quot;&gt; &lt;!-- 标签列表 --&gt; &lt;div class=&quot;tag&quot;&gt;HTML&lt;/div&gt; &lt;div class=&quot;tag&quot;&gt;CSS&lt;/div&gt; &lt;div class=&quot;tag&quot;&gt;Python&lt;/div&gt; &lt;div class=&quot;tag&quot;&gt;JavaScript&lt;/div&gt; &lt;div class=&quot;tag&quot;&gt;Java&lt;/div&gt; &lt;/div&gt; &lt;!-- 剩余数量指示器 --&gt; &lt;div class=&quot;remaining-counter&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const tagsWrapper = document.querySelector(&quot;.tags-wrapper&quot;); Array.from(tagsWrapper.children).forEach((tag) =&gt; { const { y } = tag.getBoundingClientRect(); if (y &gt; 0) tag.classList.add(&quot;tag-hidden&quot;); }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果如下","link":"/2023/06/css%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"title":"docker常用指令","text":"一、Docker 是什么？Docker 是一个开源的容器化平台，用于将应用程序及其依赖项打包成轻量级、可移植的容器。容器基于镜像运行，提供隔离的环境，确保应用在不同环境中行为一致。 核心概念： 镜像（Image）：只读模板（如操作系统、软件环境的快照）。 容器（Container）：镜像的运行实例（进程隔离）。 仓库（Registry）：存储和分发镜像的服务（如 Docker Hub）。 Dockerfile：定义镜像构建步骤的脚本。 Docker Compose：管理多容器应用的工具。 二、Docker 常见指令1. 镜像管理 指令 说明 docker images 查看本地镜像列表 docker pull &lt;镜像名:标签&gt; 从仓库拉取镜像（默认标签为 latest） docker build -t &lt;镜像名&gt; . 根据当前目录的 Dockerfile 构建镜像 docker rmi &lt;镜像ID&gt; 删除本地镜像 docker search &lt;关键词&gt; 在 Docker Hub 搜索镜像 2. 容器操作 指令 说明 docker run -d -p 主机端口:容器端口 --name &lt;容器名&gt; &lt;镜像名&gt; 创建并启动容器（-d 后台运行，-p 端口映射） docker ps 查看运行中的容器（加 -a 查看所有） docker start/stop/restart &lt;容器名&gt; 启动/停止/重启容器 docker exec -it &lt;容器名&gt; /bin/bash 进入容器内部的交互式终端 docker rm &lt;容器名&gt; 删除已停止的容器 docker logs &lt;容器名&gt; 查看容器日志（加 -f 实时跟踪） 3. 网络与数据卷 指令 说明 docker network ls 查看 Docker 网络列表 docker volume create &lt;卷名&gt; 创建数据卷 docker volume ls 查看数据卷列表 4. Docker Compose 指令 说明 docker-compose up -d 启动 Compose 定义的所有服务（-d 后台运行） docker-compose down 停止并删除所有容器、网络 docker-compose build 重新构建镜像 docker-compose logs 查看服务日志 5. 系统管理 指令 说明 docker system prune 清理无用镜像、容器、网络等资源 docker stats 实时查看容器资源占用（CPU/内存等） docker info 显示 Docker 系统信息 三、快速案例1. 运行 Nginx 容器1234567# 拉取镜像docker pull nginx# 启动容器（映射端口 80）docker run -d -p 80:80 --name my-nginx nginx# 访问 http://localhost 即可看到 Nginx 默认页面。 2. 构建自定义镜像创建一个 Dockerfile 123FROM alpineRUN apk add --no-cache curlCMD [&quot;curl&quot;, &quot;https://example.com&quot;] 构建并运行： 12docker build -t my-curl .docker run my-curl","link":"/2019/09/docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"Jenkins&amp;GitLab安装","text":"1. 使用 Docker 安装 Jenkins1.1 拉取官方 Jenkins 镜像1docker pull jenkins/jenkins:lts 1.2 启动 Jenkins 容器 将 Jenkins 数据持久化到宿主机目录或使用 Docker volume。 12345678# 使用 volume 进行数据持久化，并映射端口 docker run -d \\ -p 8080:8080 \\ -p 50000:50000 \\ -v jenkins_home:/var/jenkins_home \\ --name jenkins \\ jenkins/jenkins:lts 1.3 初次配置 打开浏览器访问 http://&lt;宿主机IP&gt;:8080。 根据页面提示获取初始管理员密码： 1docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword 输入密码后安装推荐的插件，创建管理员账号并完成配置。 2. 使用 Docker 安装 GitLab2.1 拉取 GitLab CE 官方镜像1docker pull gitlab/gitlab-ce:latest 2.2 启动 GitLab 容器将 GitLab 配置、日志和数据目录映射到宿主机目录，以便持久化数据。 1234567891011# 请确保 /srv/gitlab/config、/srv/gitlab/logs 和 /srv/gitlab/data 目录在宿主机上已创建，并且拥有适当权限。# --hostname 参数建议使用你自己的域名或 IP 地址。docker run --detach \\ --hostname gitlab.example.com \\ --publish 443:443 --publish 80:80 --publish 22:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab \\ --volume /srv/gitlab/logs:/var/log/gitlab \\ --volume /srv/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 2.3 初始化配置 打开浏览器访问 http://&lt;宿主机IP&gt;。 根据提示设置初始管理员密码和其他相关配置。 3. GitLab 提交代码自动触发 Jenkins 构建自动化流程主要依赖 GitLab 的 Webhook 和 Jenkins 的相应插件。 3.1 在 GitLab 配置 Webhook 登录 GitLab 仓库，进入项目页面。 点击左侧菜单中的 Settings（设置） -&gt; Webhooks。 在 URL 输入 Jenkins 用于接收 GitLab 触发请求的地址。例如：http://:8080/gitlab-webhook/ 根据需要勾选触发条件，一般选择 Push events（推送事件），也可以选择 Merge request events 等。 若需要可以配置 Secret Token（在 Jenkins 配置中需要与之匹配）。 点击 Add webhook 保存，并可点击 Test 测试是否正常。 3.2 在 Jenkins 中配置相应项目安装插件 登录 Jenkins 管理界面。 进入 Manage Jenkins（管理 Jenkins） -&gt; Manage Plugins（插件管理）。 在 Available（可选） 标签下搜索并安装以下插件：Git Plugin、GitLab Plugin 或 GitLab Hook Plugin 创建 Jenkins 项目(Pipeline 项目) 新建一个 Pipeline 项目。 在项目根目录创建一个 Jenkinsfile，并在其中定义流水线步骤 12345678910111213141516171819202122 pipeline { agent any stages { stage('Checkout') { steps { git branch: 'master', url: 'http://gitlab.example.com/your-group/your-project.git' } } stage('Build') { steps { sh 'npm install' sh 'npm run build' } } stage('Test') { steps { sh 'npm test' } } }} 在 构建触发器 中同样勾选 Build when a change is pushed to GitLab，确保与 GitLab Webhook 的配置一致。 3.3 验证自动触发构建 在 GitLab 中向仓库提交前端代码（例如 push 一次新 commit）。 GitLab 根据 Webhook 配置向 Jenkins 发送 POST 请求。 Jenkins 收到请求后自动触发对应项目的构建流程。 在 Jenkins 控制台中观察构建日志，确保流水线正常执行。","link":"/2020/12/Jenkins&GitLab/"},{"title":"h5自定义微信分享","text":"1. 需求背景 微信分享新闻时即可显示自定义的标题、描述和图标。 2. 前期准备2.1 注册微信公众号 需要认证的订阅号或服务号 进入微信公众平台 -&gt; 设置 -&gt; 公众号设置 -&gt; 功能设置 -&gt; 配置「JS接口安全域名」 2.2 获取开发者ID 进入「开发」-&gt;「基本配置」记录 AppID 和 AppSecret 3. 后端生成签名123456789101112131415161718192021222324252627282930const crypto = require('crypto');// 1. 获取access_tokenasync function getAccessToken() { const res = await axios.get( `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=${APPID}&amp;secret=${APPSECRET}` ); return res.data.access_token;}// 2. 获取jsapi_ticketasync function getJsapiTicket(accessToken) { const res = await axios.get( `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=${accessToken}&amp;type=jsapi` ); return res.data.ticket;}// 3. 生成签名function createSignature(ticket, url) { const noncestr = Math.random().toString(36).substr(2, 15); const timestamp = Math.floor(Date.now() / 1000); const str = `jsapi_ticket=${ticket}&amp;noncestr=${noncestr}&amp;timestamp=${timestamp}&amp;url=${url}`; const sha1 = crypto.createHash('sha1'); sha1.update(str); const signature = sha1.digest('hex'); return { noncestr, timestamp, signature };} 4.前端配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- 1. 引入JS文件 --&gt;&lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 2. 通过接口获取签名配置axios.get('/get-wechat-config', { params: { url: window.location.href } }) .then(res =&gt; { const config = res.data; // 3. 初始化配置 wx.config({ debug: false, // 调试模式 appId: config.appId, timestamp: config.timestamp, nonceStr: config.noncestr, signature: config.signature, jsApiList: [ // 需要使用的接口列表 'updateAppMessageShareData', 'updateTimelineShareData' ] }); // 4. 配置分享内容 wx.ready(() =&gt; { // 分享给朋友 wx.updateAppMessageShareData({ title: '自定义标题', desc: '分享描述内容', link: window.location.href, imgUrl: 'https://your-domain.com/share-icon.png' }); // 分享到朋友圈 wx.updateTimelineShareData({ title: '朋友圈分享标题', link: window.location.href, imgUrl: 'https://your-domain.com/share-icon.png' }); }); // 错误处理 wx.error(err =&gt; { console.error('微信配置错误:', err); }); });&lt;/script&gt;","link":"/2024/04/h5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB/"},{"title":"h5唤起APP","text":"1. 原理1.1 自定义 URI SchemeAPP 在启动时注册一个自定义协议（如 myapp://），当 H5 页面跳转到该协议对应的 URL 时，系统会识别并唤起对应 APP，同时将 URL 中携带的参数传递给 APP 进行处理，达到跳转到指定页面的目的。 缺点: 当 APP 未安装时，跳转会失败且不会有反馈，需要配合超时处理来跳转到下载页面。 1.2 Universal Links/App Links 利用 HTTPS 协议，在服务器上配置对应的关联文件（iOS 为 apple-app-site-association，Android 为 assetlinks.json），当用户点击链接时，系统检测到该链接与 APP 的关联关系，如果 APP 已安装则直接唤起，否则打开网页。 优点： 用户体验更好，兼容性较强。 缺点： 配置较为复杂，要求服务器配置支持。 1.3 Intent Scheme（针对 Android）Android 使用 intent:// 格式，通过 intent 调用方式唤起 APP。链接格式中包含包名、scheme 等信息，可指定 fallback URL 当 APP 未安装时跳转到应用市场。 优点： 在 Android 平台上效果较好。 缺点： 部分浏览器可能对 intent 处理不一致，需要兼容性测试。 2.实际流程2.1 判断设备平台 根据 navigator.userAgent 判断当前访问的设备是 iOS、Android 还是其他。 2.2 唤起链接 iOS： 使用自定义 URI Scheme 或 Universal Link（推荐 iOS 9 以上使用 Universal Link） Android： 使用 Intent Scheme 或自定义 URI Scheme 2.3 发起唤起请求 在 H5 页面中通过 window.location.href 跳转到唤起链接。 同时记录当前时间，以便判断是否唤起成功。 2.4 跳转失败处理 使用 setTimeout 设定一个超时时间（如 1.5-2 秒），如果在超时时间内页面没有跳转（即 APP 没有响应，可能未安装），则跳转到应用下载页（App Store/Google Play）。 2.5 防止重复跳转 可通过 URL 参数记录唤起次数或状态，避免重复跳转带来的问题。 3. 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;唤起 APP 示例&lt;/title&gt; &lt;script&gt; function openApp() { var ua = navigator.userAgent.toLowerCase(); // 构造唤起链接，根据实际情况配置自定义 Scheme 或 Universal Link var schemeUrl = &quot;myapp://page?param=123&quot;; // 对应的 Intent Scheme 链接（仅针对 Android） var intentUrl = &quot;intent://page?param=123#Intent;scheme=myapp;package=com.example.myapp;end&quot;; // APP 下载页面（根据实际情况配置） var iosDownloadUrl = &quot;https://apps.apple.com/app/yourapp&quot;; var androidDownloadUrl = &quot;https://play.google.com/store/apps/details?id=com.example.myapp&quot;; // 记录当前时间 var startTime = Date.now(); if (/iphone|ipad|ipod/.test(ua)) { // iOS 系统：优先使用自定义 Scheme（或使用 Universal Link） window.location.href = schemeUrl; } else if (/android/.test(ua)) { // Android 系统：使用 Intent 链接 window.location.href = intentUrl; } else { // 其他设备或无法识别的系统，直接跳转到下载页面 window.location.href = iosDownloadUrl; } // 设置超时判断：如果在指定时间内页面没有跳转，则认为 APP 未安装，跳转到下载页 setTimeout(function() { var elapsed = Date.now() - startTime; // 超时时间可根据实际测试调整，通常 1500-2000 毫秒 if (elapsed &lt; 2000) { if (/iphone|ipad|ipod/.test(ua)) { window.location.href = iosDownloadUrl; } else if (/android/.test(ua)) { window.location.href = androidDownloadUrl; } } }, 1500); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;点击按钮唤起 APP 并跳转到指定页面&lt;/h2&gt; &lt;button onclick=&quot;openApp()&quot;&gt;打开 APP&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2024/06/h5%E5%94%A4%E8%B5%B7APP/"},{"title":"iframe标签使用总结","text":"一、&lt;iframe&gt; 的作用 嵌入外部内容 加载第三方页面（如地图、视频、广告等）。 隔离不同来源的内容（如跨域资源）。 沙箱环境 通过 sandbox 属性限制子页面的行为（如脚本执行、表单提交）。 模块化开发 独立加载子模块，避免样式/脚本污染主页面。 二、&lt;iframe&gt; 的优缺点优点 特性 说明 内容隔离 子页面与父页面 CSS/JS 作用域隔离，避免冲突。 并行加载 主页面与子页面可并行加载，提升性能。 跨域支持 可嵌入不同域的内容（需配合 CORS）。 沙箱安全 通过 sandbox 限制子页面权限，降低安全风险。 缺点 问题 说明 SEO 不友好 搜索引擎可能无法抓取 iframe 内部内容。 性能开销 多个 iframe 会增加内存和网络请求。 管理复杂 需要动态调整尺寸（如自适应高度）、处理内部页面事件等。 安全风险 恶意 iframe 可能引发点击劫持（Clickjacking）攻击。 三、&lt;iframe&gt; 跨消息传递 (postMessage) 发送消息 12345// 父页面向子页面发送消息iframe.contentWindow.postMessage(data, targetOrigin);// 子页面向父页面发送消息window.parent.postMessage(data, targetOrigin); 接收消息1234window.addEventListener('message', (event) =&gt; { if (event.origin !== '信任的域名') return; // 验证来源 console.log('收到消息:', event.data);}); 四、注意事项 安全性 始终验证 event.origin，防止恶意网站伪造消息。 数据格式 postMessage 支持传递字符串、对象等可序列化数据。 性能优化 避免频繁通信，减少性能损耗。 跨域限制 若子页面与父页面不同源，需确保子页面部署正确的 CORS 策略。","link":"/2017/11/iframe%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"找工作","text":"资深前端开发工程师，8年以上复杂业务系统开发经验，专注React+TypeScript技术生态，擅长PC端中后台开发与性能优化。主导开发过多个高可用性PC端业务系统，通过模块化设计与TypeScript类型工程规范，实现代码复用率提升40%+，长期维护成本降低30%。 在移动端领域具备跨平台开发能力：熟悉Taro跨端框架开发小程序，实践过原生Native与H5移动端SPA应用，理解Hybrid混合开发技术要点。注重多端体验一致性，能基于业务场景灵活选用技术方案，曾主导PC+移动多端协同项目，实现核心业务组件库跨平台复用。 深度参与前端工程化建设，主导搭建基于Webpack的构建体系，集成Lint规则、Commit规范与自动化测试（Jest/Testing Library），实现CI/CD流水线部署效率提升50%。持续关注React Server Components、Rust工具链等前沿方向，熟练使用Node.js开发，具备全栈技术视野。","link":"/2025/03/hello-world/"},{"title":"script标签部分属性总结","text":"一、script、script async 和 script defer的区别以下是三者在 HTML 中加载和执行 JavaScript 的对比： 特性 &lt;script&gt; &lt;script async&gt; &lt;script defer&gt; 加载行为 立即加载并阻塞 HTML 解析 异步加载，不阻塞 HTML 解析 异步加载，不阻塞 HTML 解析 执行时机 立即执行（阻塞后续解析） 加载完成后立即执行（可能中断 HTML 解析） 在 HTML 解析完成后、DOMContentLoaded 事件前按顺序执行 执行顺序 按文档顺序执行 不保证顺序（先下载完成的先执行） 严格按文档顺序执行 适用场景 需立即执行的脚本 独立脚本（如统计代码、第三方库） 依赖 DOM 或需要顺序执行的脚本 是否等待 HTML 解析 是 否 是（但加载过程不阻塞解析） 详细说明：1. 普通 &lt;script&gt; 遇到标签时立即停止 HTML 解析，下载并执行脚本。 若脚本较大或网络延迟，会显著延长页面加载时间。 2. &lt;script async&gt; 异步下载：脚本与 HTML 解析并行加载。 立即执行：下载完成后立即执行（可能中断 HTML 解析）。 不保证顺序：多个 async 脚本的执行顺序不可预测。 3. &lt;script defer&gt; 异步下载：脚本与 HTML 解析并行加载。 延迟执行：所有脚本在 HTML 解析完成后按文档顺序执行。 保证顺序：适合有依赖关系的脚本（如库文件 + 业务代码）。 示例：123456789&lt;!-- 阻塞解析 --&gt;&lt;script src=&quot;blocking.js&quot;&gt;&lt;/script&gt;&lt;!-- 异步加载，不保证顺序 --&gt;&lt;script async src=&quot;analytics.js&quot;&gt;&lt;/script&gt;&lt;!-- 异步加载，按顺序执行 --&gt;&lt;script defer src=&quot;library.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;app.js&quot;&gt;&lt;/script&gt; 小结： 阻塞问题：普通 &lt;script&gt; 会阻塞渲染，async/defer 不会。 执行顺序：defer 保持顺序，async 不保证。 DOM 依赖：defer 脚本可安全操作 DOM，async 脚本可能操作未解析的 DOM。 性能优化：优先用 defer，独立脚本用 async，避免普通 &lt;script&gt; 在头部阻塞。 二、&lt;script&gt; 的 type 类型 类型值 描述 默认（省略或 text/javascript） 标准 JavaScript 脚本，浏览器按传统方式解析执行。 module 表示脚本为 ES6 模块，支持 import/export，自动启用严格模式，默认 defer 行为。 text/typescript 需配合编译器（如 TypeScript）使用，浏览器不会直接执行。 application/json 非可执行脚本，用于存储数据（需配合其他脚本解析）。 text/html 非脚本内容，浏览器会忽略。 三、多个标签存在时的变量提升规则1. 同步脚本（无 async/defer）123456789101112&lt;script&gt; console.log(a); // undefined（变量提升） var a = 1;&lt;/script&gt;&lt;script&gt; console.log(a); // 1（前一个脚本已赋值）&lt;/script&gt;&lt;!-- 规则 变量/函数声明按脚本顺序提升，但跨脚本的变量提升不会合并。 前一个脚本的变量赋值对后续脚本可见（全局作用域共享）。 --&gt; 2. 带 defer 的脚本123456789101112&lt;script defer&gt; console.log(b); // 1（所有 `defer` 脚本按顺序执行，前一个脚本已赋值）&lt;/script&gt;&lt;script defer&gt; var b = 1;&lt;/script&gt;&lt;!-- 规则： 所有 defer 脚本在 HTML 解析完成后按文档顺序执行。 变量提升逻辑等同于同步脚本，但执行时机延迟。 --&gt; 3. 带 async 的脚本123456789101112&lt;script async&gt; console.log(c); // 可能输出 `undefined` 或 `2`（取决于加载顺序）&lt;/script&gt;&lt;script async&gt; var c = 2;&lt;/script&gt;&lt;!-- 规则： 异步脚本加载完成立即执行，执行顺序不可控。 变量可能存在竞态条件，需避免依赖其他 async 脚本的变量。 --&gt; 4. 模块脚本（type=”module”）123456789101112&lt;script type=&quot;module&quot;&gt; console.log(d); // 报错（模块作用域隔离，无法访问全局变量）&lt;/script&gt;&lt;script&gt; var d = 3;&lt;/script&gt;&lt;!-- 规则： 模块脚本拥有独立作用域，变量不会提升到全局。 跨模块变量需通过 import/export 显式传递。 --&gt; 小结： 变量提升范围： 同步脚本、defer 脚本：全局作用域，按顺序提升。 async 脚本：全局作用域，但执行顺序不可控。 模块脚本：模块作用域，无全局提升。 依赖管理建议： 优先用 defer 保证执行顺序，避免 async 变量冲突。 使用 type=”module” 隔离作用域，减少全局污染。 严格模式： 模块脚本自动启用严格模式（var 不会绑定到 window）。","link":"/2018/05/script%E6%A0%87%E7%AD%BE%E9%83%A8%E5%88%86%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93/"},{"title":"service worker更新方案","text":"1. 默认（浏览器自动）更新机制浏览器会在每次页面加载时自动检查 sw.js 文件（受 HTTP 缓存策略控制）。当检测到文件内容有变动时，新 SW 会被下载并进入“安装”阶段，但不会立刻激活，而是进入 waiting 状态，直到所有受控页面关闭后才激活。 优点 对用户来说无缝，无需干预，适合大多数场景。 浏览器自动处理，减少开发复杂性。缺点 用户可能不知道更新发生，可能延迟体验新功能。 如果更新涉及重大变化，可能会导致短暂的不一致。示例 12345678910// 注册 Service Worker（默认自动更新机制由浏览器处理） if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js') .then(registration =&gt; { console.log('SW 注册成功，作用域：', registration.scope); }) .catch(error =&gt; { console.error('SW 注册失败：', error); }); } 2. 强制立即更新方案（skipWaiting + clients.claim）在 SW 的 install 事件中调用 self.skipWaiting()，使新 SW 不再等待旧 SW 退出；在 activate 事件中调用 self.clients.claim()，使新 SW 立即接管所有客户端。 优点 确保所有用户快速获取最新版本，减少安全风险。 适合需要立即生效的场景。缺点 可能打断用户当前操作，造成不良体验。 如果更新不兼容，可能导致应用崩溃或混乱。示例 12345678910// sw.js 文件内self.addEventListener('install', event =&gt; { // 强制新 SW 安装后直接进入 waiting 状态后跳过等待 self.skipWaiting();});self.addEventListener('activate', event =&gt; { // 立即接管所有客户端 event.waitUntil(self.clients.claim());}); 3. 手动触发更新（registration.update()）在客户端通过调用 registration.update() 方法来手动检查和下载更新版本的 SW。优点 赋予用户控制权，适合希望用户决定更新时机的情况。 可用于特定场景，如用户明确要求检查更新。缺点 用户可能忘记点击更新，导致使用过时版本。 需要额外的UI设计，增加开发工作量。示例 12345678910111213141516if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(registration) { document.getElementById('updateButton').addEventListener('click', function() { registration.update().then(function() { console.log('手动检查 SW 更新完成'); }).catch(function(error) { console.log('更新失败', error); }); }); }).catch(function(error) { console.log('注册失败', error); }); });} 4. 用户提示更新（通知用户刷新页面）监听 SW 的 onupdatefound 事件，当检测到新版本已安装（但仍处于 waiting 状态）时，提示用户刷新页面以激活新 SW。常配合 skipWaiting() 使用，但让用户确认后再调用，避免突然更新带来不兼容问题。 优点 告知用户有更新可用，增强透明度。 赋予用户选择权，避免意外刷新打断操作。缺点 需要用户手动刷新，可能延迟更新。 UI提示设计需谨慎，避免过于频繁或打扰用户。示例 123456789101112131415161718192021222324252627282930if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(reg) { if (reg.waiting) { showUpdatePrompt(); } reg.onupdatefound = function() { var installingWorker = reg.installing; installingWorker.onstatechange = function() { if (installingWorker.state === 'installed') { if (navigator.serviceWorker.controller) { showUpdatePrompt(); } } }; }; }).catch(function(error) { console.log('注册失败', error); }); });}function showUpdatePrompt() { var prompt = document.getElementById('updatePrompt'); prompt.classList.add('visible'); document.getElementById('reloadButton').addEventListener('click', function() { window.location.reload(); });}","link":"/2024/02/service%20worker%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/"},{"title":"WebSocket 心跳检测机制","text":"协议规范与浏览器 API 的差异1. 协议规范（RFC 6455） 双向 Ping/Pong 支持：客户端和服务端均可主动发送标准 Ping 帧，接收方必须回复 Pong 帧。 控制帧特性：Ping/Pong 是 WebSocket 协议定义的控制帧，不占用应用层数据通道。 2. 浏览器 API 限制 客户端无法主动发送 Ping：JavaScript 的 WebSocket API 未开放 ping() 方法。 自动响应 Pong：浏览器会自动响应服务端发送的 Ping 帧，但无法自定义处理逻辑。 应用层心跳替代：若需客户端主动检测，需通过发送普通数据消息（如 JSON）模拟心跳。 实现方案与示例方案 1：服务端发送标准 Ping 帧（推荐）服务端代码（Node.js + ws 库）12345678910111213141516171819const WebSocket = require('ws');const wss = new WebSocket.Server({ port: 8080 });wss.on('connection', (ws) =&gt; { // 每 30 秒发送一次 Ping const interval = setInterval(() =&gt; { if (ws.readyState === WebSocket.OPEN) { ws.ping(); // 发送标准 Ping 帧 } }, 30000); // 监听 Pong 响应 ws.on('pong', () =&gt; { console.log('收到客户端自动回复的 Pong'); }); // 清理定时器 ws.on('close', () =&gt; clearInterval(interval));}); 浏览器客户端行为123const ws = new WebSocket('ws://localhost:8080');// 浏览器自动处理服务端 Ping，无需手动编码// 无法通过 API 主动发送 Ping！ 方案 2：客户端发送应用层心跳（兼容浏览器）客户端代码（浏览器）12345678910111213141516171819202122const ws = new WebSocket('ws://localhost:8080');// 自定义心跳消息const sendHeartbeat = () =&gt; { if (ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: 'HEARTBEAT' })); }};// 每 20 秒发送一次const interval = setInterval(sendHeartbeat, 20000);// 监听服务端确认ws.onmessage = (event) =&gt; { const msg = JSON.parse(event.data); if (msg.type === 'HEARTBEAT_ACK') { console.log('服务端连接正常'); }};// 清理ws.onclose = () =&gt; clearInterval(interval); 服务端响应逻辑：12345678wss.on('connection', (ws) =&gt; { ws.on('message', (data) =&gt; { const msg = JSON.parse(data); if (msg.type === 'HEARTBEAT') { ws.send(JSON.stringify({ type: 'HEARTBEAT_ACK' })); // 确认心跳 } });}); 结论1. 协议能力 WebSocket 协议支持双向 Ping/Pong，但浏览器 API 限制客户端无法主动发送 Ping 帧。 2. 服务端优先策略 推荐服务端主动发送标准 Ping 帧： 高效：使用协议控制帧，数据量更小。 自动处理：浏览器自动回复 Pong，无需额外代码，代码简洁。 适用场景：浏览器客户端为主的实时应用（如在线聊天、游戏） 3. 客户端应用层心跳 客户端发送应用层心跳 + 服务端响应 优点: 灵活控制逻辑 缺点： 增加冗余数据流量（自定义消息需包含协议头等）。 需手动实现超时检测逻辑。 适用场景： 需客户端主动检测服务端存活状态（如控制端设备）。 浏览器需兼容低版本 WebSocket 实现。 4. 双端混合检测（高可靠性场景） 同时使用服务端 Ping 和客户端应用层心跳。 适用场景： 金融交易系统要求秒级连接状态感知。 物联网设备双向健康检查。","link":"/2024/01/websocket%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/"},{"title":"web安全","text":"1.常见的 Web 安全攻击方式1.1 跨站脚本攻击（XSS） 原理：攻击者将恶意 JavaScript 代码注入到页面中，当其他用户访问该页面时，恶意代码在其浏览器中执行，可能窃取 Cookie、劫持会话或发起钓鱼攻击。 防御方法: 输出转义：根据上下文（HTML、属性、JS 等）对用户输入进行适当的转义。 使用安全的模板引擎：例如 EJS、Handlebars 等默认支持转义。 Content Security Policy (CSP)：通过设置 CSP 限制加载资源的来源，降低 XSS 攻击风险。 示例：修复 XSS 漏洞的 HTML 模板 123456789&lt;!-- 不安全版本 --&gt;&lt;div&gt; 您的评论：&lt;%= userComment %&gt;&lt;/div&gt;&lt;!-- 安全版本（EJS 默认会对 &lt;%= %&gt; 进行 HTML 转义） --&gt;&lt;div&gt; 您的评论：&lt;%= userComment %&gt;&lt;/div&gt; 1.2 跨站请求伪造（CSRF） 原理：攻击者诱导已登录用户在不知情的情况下向目标站点发送恶意请求，从而执行诸如转账、修改密码等操作。 防御方法: CSRF 令牌：在每个敏感操作中，生成并验证令牌。 验证 Referer：检查请求来源是否来自可信域名。 SameSite Cookie 属性：设置 Cookie 的 SameSite 属性（Strict 或 Lax）。 示例: 使用 Express 的 csurf 中间件 12345678910111213141516171819202122232425const express = require('express');const cookieParser = require('cookie-parser');const csrf = require('csurf');const bodyParser = require('body-parser');const app = express();app.use(cookieParser());app.use(bodyParser.urlencoded({ extended: false }));// 启用 CSRF 防护，令牌存放在 Cookie 中const csrfProtection = csrf({ cookie: true });app.get('/form', csrfProtection, (req, res) =&gt; { // 页面中嵌入 CSRF token 隐藏字段 res.send(` &lt;form action=&quot;/process&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;${req.csrfToken()}&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; `);});app.post('/process', csrfProtection, (req, res) =&gt; { res.send('请求处理成功！');});app.listen(3000, () =&gt; console.log('Server running on port 3000')); 1.3 SQL 注入 原理：攻击者将恶意 SQL 语句注入到数据库查询中，可能导致数据泄露或篡改。 防御方法：使用参数化查询或预编译语句，而不要直接拼接 SQL 字符串。 示例：使用 mysql 模块进行参数化查询 12345678910111213141516171819202122const mysql = require('mysql');const connection = mysql.createConnection({ host: 'localhost', user: 'root', password: 'password', database: 'test'});connection.connect();app.post('/login', (req, res) =&gt; { const username = req.body.username; const password = req.body.password; // 使用 ? 占位符，确保参数被正确转义 const query = 'SELECT * FROM users WHERE username = ? AND password = ?'; connection.query(query, [username, password], (error, results) =&gt; { if (error) throw error; // 根据查询结果处理登录逻辑 res.send(results.length ? '登录成功' : '用户名或密码错误'); });}); 1.4 命令注入 原理：如果将用户输入直接传给系统命令（如 exec），攻击者可能注入恶意命令执行。 防御方法：避免直接使用字符串拼接执行命令；如需执行命令，请使用 execFile 替代 exec。示例：使用 execFile 执行命令 12345678910const { execFile } = require('child_process');// 只执行固定命令，用户输入作为参数时需严格校验execFile('ls', ['-l', '/usr'], (err, stdout, stderr) =&gt; { if (err) { console.error(err); return; } console.log(stdout);}); 1.5 目录遍历和文件上传/下载漏洞 原理：通过修改 URL 参数或上传文件路径，攻击者可下载或覆盖服务器敏感文件。 防御方法： 限制文件路径：使用白名单或将文件存储在非 Web 根目录中。 验证文件类型和大小：对上传文件进行严格检查。 2. 防御措施的通用做法2.1 输入校验与输出转义 对所有来自用户的数据（URL 参数、表单、Cookie 等）进行严格的校验与过滤。 根据输出上下文（HTML、JS、CSS、URL）使用不同的转义规则，避免“过滤或不过滤”的问题。 2.2 使用安全中间件 Helmet：帮助设置 HTTP 头信息，防止 XSS、点击劫持等攻击。示例：在 Express 中使用 Helmet 123const helmet = require('helmet');app.use(helmet()); 2.3 使用 HTTPS 和安全 Cookie 采用 HTTPS 加密数据传输。 设置 Cookie 的 HttpOnly 和 Secure 标志，防止被 JavaScript 读取或在非安全连接上传输。 3. 综合示例下面是一个简单的 Express 应用，综合使用了 Helmet、CSRF 防护、参数化查询以及安全的命令执行示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const express = require('express');const helmet = require('helmet');const cookieParser = require('cookie-parser');const csrf = require('csurf');const bodyParser = require('body-parser');const mysql = require('mysql');const { execFile } = require('child_process');const app = express();// 安全中间件app.use(helmet());app.use(cookieParser());app.use(bodyParser.urlencoded({ extended: false }));// 设置 CSRF 防护const csrfProtection = csrf({ cookie: true });app.get('/form', csrfProtection, (req, res) =&gt; { res.send(` &lt;form action=&quot;/submit&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;${req.csrfToken()}&quot;&gt; 用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; `);});// 建立数据库连接（请根据实际环境配置）const connection = mysql.createConnection({ host: 'localhost', user: 'root', password: 'password', database: 'test'});connection.connect();// 登录处理，使用参数化查询防止 SQL 注入app.post('/submit', csrfProtection, (req, res) =&gt; { const username = req.body.username; const password = req.body.password; const query = 'SELECT * FROM users WHERE username = ? AND password = ?'; connection.query(query, [username, password], (error, results) =&gt; { if (error) throw error; if (results.length) { res.send('登录成功！'); } else { res.send('用户名或密码错误'); } });});// 示例：安全执行系统命令（仅作为示例，实际业务中谨慎调用）app.get('/list', (req, res) =&gt; { // 固定参数，避免直接使用用户输入 execFile('ls', ['-l', '/usr'], (err, stdout, stderr) =&gt; { if (err) { res.status(500).send('执行命令出错'); return; } res.type('text/plain').send(stdout); });});app.listen(3000, () =&gt; { console.log('Server running on port 3000');}); 4. 小结 严格校验所有输入，确保数据符合预期格式； 根据输出上下文进行正确的转义，防止数据被误解析为代码； 使用成熟的安全中间件（如 Helmet、csurf）和参数化查询防止常见攻击； 采用 HTTPS、设置安全 Cookie 以及其他防护措施降低风险。","link":"/2019/06/web%E5%AE%89%E5%85%A8/"},{"title":"大数据表格性能优化","text":"需求背景20万级数据量复杂计算 1. 虚拟滚动表格组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// VirtualTable.tsximport React from 'react';import { Table } from 'antd';import { FixedSizeList as List } from 'react-window';import type { ColumnsType, TableProps } from 'antd/es/table';const ROW_HEIGHT = 54; // 根据实际样式调整行高const VirtualTable = &lt;RecordType extends object&gt;({ columns, dataSource, scroll,}: TableProps&lt;RecordType&gt;) =&gt; { const width = (columns as ColumnsType&lt;RecordType&gt;).reduce( (total, col) =&gt; total + (Number(col.width) || 100), 0 ); const virtualList = ({ height, onScroll, }: { height: number; onScroll: (scrollInfo: { scrollLeft: number }) =&gt; void; }) =&gt; { return ( &lt;List height={height} itemCount={dataSource.length} itemSize={ROW_HEIGHT} width={width} onScroll={onScroll} &gt; {({ index, style }) =&gt; { const record = dataSource[index]; return ( &lt;div style={{ ...style, display: 'flex', alignItems: 'center', borderBottom: '1px solid #e8e8e8', }} &gt; {(columns as ColumnsType&lt;RecordType&gt;).map((col) =&gt; ( &lt;div key={col.key || col.dataIndex?.toString()} style={{ width: col.width, padding: '8px', boxSizing: 'border-box', }} &gt; {col.render ? col.render(record[col.dataIndex as keyof RecordType], record, index) : record[col.dataIndex as keyof RecordType]} &lt;/div&gt; ))} &lt;/div&gt; ); }} &lt;/List&gt; ); }; return ( &lt;Table&lt;RecordType&gt; columns={columns} dataSource={dataSource} pagination={false} scroll={scroll} components={{ body: virtualList, }} /&gt; );};export default VirtualTable; 2. 创建 Web Worker 文件123456789101112131415161718192021222324252627282930313233343536373839404142// data.worker.tstype WorkerMessage = { type: 'SORT' | 'FILTER'; data: any[]; payload?: any;};self.onmessage = (e: MessageEvent&lt;WorkerMessage&gt;) =&gt; { const { type, data, payload } = e.data; let result; switch (type) { case 'SORT': result = handleSort(data, payload); break; case 'FILTER': result = handleFilter(data, payload); break; default: result = data; } self.postMessage(result);};// 排序逻辑function handleSort(data: any[], { field, order }: { field: string; order: 'asc' | 'desc' }) { return [...data].sort((a, b) =&gt; { const valA = a[field]; const valB = b[field]; return order === 'asc' ? valA - valB : valB - valA; });}// 过滤逻辑function handleFilter(data: any[], keyword: string) { return data.filter(item =&gt; Object.values(item).some(val =&gt; String(val).toLowerCase().includes(keyword.toLowerCase()) ) );} 3. 在组件中集成 Worker1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// App.tsximport React, { useEffect, useState, useCallback } from 'react';import VirtualTable from './VirtualTable';import type { ColumnsType } from 'antd/es/table';interface DataType { key: string; name: string; age: number; address: string;}const App: React.FC = () =&gt; { const [data, setData] = useState&lt;DataType[]&gt;([]); const workerRef = React.useRef&lt;Worker&gt;(); // 初始化 Worker useEffect(() =&gt; { workerRef.current = new Worker(new URL('./data.worker.ts', import.meta.url)); workerRef.current.onmessage = (e) =&gt; setData(e.data); return () =&gt; workerRef.current?.terminate(); }, []); // 加载初始数据 useEffect(() =&gt; { fetch('/api/big-data').then(res =&gt; res.json()).then(rawData =&gt; { workerRef.current?.postMessage({ type: 'SORT', data: rawData, payload: { field: 'age', order: 'asc' } }); }); }, []); // 交互处理函数 const handleSort = useCallback((field: string, order: 'asc' | 'desc') =&gt; { workerRef.current?.postMessage({ type: 'SORT', data, payload: { field, order } }); }, [data]); const columns: ColumnsType&lt;DataType&gt; = [ { title: 'Name', dataIndex: 'name', width: 200, sorter: true, onHeaderCell: () =&gt; ({ onClick: () =&gt; handleSort('name', 'asc') }) }, { title: 'Age', dataIndex: 'age', width: 100, sorter: true, onHeaderCell: () =&gt; ({ onClick: () =&gt; handleSort('age', 'desc') }) }, { title: 'Address', dataIndex: 'address', width: 300 } ]; return ( &lt;VirtualTable&lt;DataType&gt; columns={columns} dataSource={data} scroll={{ y: 600 }} /&gt; );};export default App; 优化前后对比 优化前 优化后 20万数据渲染卡顿（5-10秒） 200ms以内 排序操作阻塞界面（3-5秒） 排序期间界面可操作（&lt;200ms） 内存占用 500MB+ 内存稳定在 200MB 左右 小结 虚拟滚动优化, 使用 react-window 的 FixedSizeList 实现按需渲染 Web Worker 优化, 将排序、过滤等计算密集型操作移至 Worker","link":"/2022/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"页面性能优化service worker","text":"1. Service Worker简介Service Worker 是一种在浏览器后台独立运行的脚本，主要用于实现离线缓存、资源拦截和后台同步等功能，显著提升Web应用的性能和用户体验。 2. 核心概念 独立线程：运行在浏览器后台，与主线程分离，不阻塞页面渲染。 可编程缓存：通过 Cache API 控制资源的缓存策略，支持离线访问。 事件驱动：通过监听 install、activate、fetch 等事件实现功能。 HTTPS 要求：出于安全考虑，需在 HTTPS 或 localhost 环境下运行。 作用域限制：只能控制注册路径及其子目录下的页面（如 /sw.js 的作用域为根目录）。 3. 运行流程3.1 注册（Registration） 触发条件：在页面 JavaScript 中调用 navigator.serviceWorker.register()。 流程：12345if ('serviceWorker' in navigator) {navigator.serviceWorker.register('/sw.js') .then(registration =&gt; console.log('注册成功')) .catch(err =&gt; console.log('注册失败'));} 结果：浏览器下载 sw.js，并根据其作用域决定控制的页面。 3.2 安装（Installation） 触发事件：首次注册或检测到新版本时触发 install 事件。 典型操作：预缓存关键静态资源（如 HTML、CSS、JS）。12345678 self.addEventListener('install', event =&gt; { event.waitUntil( caches.open('v1').then(cache =&gt; { return cache.addAll(['/index.html', '/style.css', '/app.js']); }) );});// 若安装失败（如资源下载失败），Service Worker 不会被激活。 3.3 激活（Activation） 触发条件：安装成功且旧版本 Service Worker 无控制的客户端（页面）时触发 activate 事件。 典型操作：清理旧缓存。12345678910self.addEventListener('activate', event =&gt; { event.waitUntil( caches.keys().then(keys =&gt; { return Promise.all(keys .filter(key =&gt; key !== 'v1') .map(key =&gt; caches.delete(key)) ); }) );}); 立即生效：通过 self.skipWaiting() 强制新版本立即激活，无需等待页面重新加载。 3.4 控制页面与拦截请求 接管控制权：激活后，新访问的页面会由当前 Service Worker 控制，可通过 clients.claim() 立即控制所有页面。 拦截请求：监听 fetch 事件，自定义响应策略（如缓存优先、网络回退）。 123456self.addEventListener('fetch', event =&gt; { event.respondWith( caches.match(event.request) .then(response =&gt; response || fetch(event.request)) );}); 4. 更新机制 版本检测：浏览器每次访问会自动检查 sw.js 是否变化（字节比对）。 并行安装：新版本在后台安装，但旧版本仍控制页面直至新版本激活。 手动更新：通过 registration.update() 强制更新。 5. 缓存策略 策略名称 实现方式 缓存优先 优先返回缓存，无缓存时请求网络并缓存。 网络优先 优先请求网络，失败时回退到缓存。 仅缓存 仅从缓存响应，适合离线场景。 动态缓存 根据请求类型动态选择策略（如 API 走网络，图片走缓存）。","link":"/2023/11/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96service%20worker/"},{"title":"性能优化指标","text":"1. 核心性能指标（Core Web Vitals）1.1 LCP (Largest Contentful Paint)定义：页面最大内容元素（如图片/文本块）的渲染时间标准：&lt; 2.5 秒优化方案： 优先关键资源加载, 使用 预加载关键资源12&lt;link rel=&quot;preload&quot; href=&quot;hero-image.jpg&quot; as=&quot;image&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;main.css&quot; as=&quot;style&quot;&gt; 优化服务器响应时间启用 CDN、开启 HTTP/2、配置缓存（Cache-Control） 延迟非关键资源使用 async/defer 延迟脚本加载1&lt;script defer src=&quot;non-critical.js&quot;&gt;&lt;/script&gt; 1.2 FID (First Input Delay)定义：用户首次交互（点击/输入）到浏览器响应的延迟标准：&lt; 100ms优化方案： 优化第三方脚本延迟加载或使用 IntersectionObserver 按需加载12345678910// 当元素进入视口时加载脚本const observer = new IntersectionObserver((entries) =&gt; { entries.forEach(entry =&gt; { if (entry.isIntersecting) { loadScript('third-party.js'); observer.unobserve(entry.target); } });});observer.observe(document.querySelector('#ad-container')); 1.3 CLS (Cumulative Layout Shift)定义：页面元素意外位移导致的视觉稳定性指标标准：&lt; 0.1优化方案： 尺寸占位为动态内容预留空间（如图片/广告位）1234&lt;!-- 图片预留宽高比例容器 --&gt;&lt;div style=&quot;position: relative; padding-top: 56.25%&quot;&gt; &lt;!-- 16:9 --&gt; &lt;img src=&quot;image.jpg&quot; style=&quot;position: absolute; top: 0; left: 0&quot;&gt;&lt;/div&gt; 避免突然插入内容使用 CSS 过渡动画代替直接显示123456789.popup {opacity: 0;transform: translateY(20px);transition: opacity 0.3s, transform 0.3s;}.popup.visible { opacity: 1; transform: translateY(0);} 2. 其他关键指标2.1 FCP (First Contentful Paint)定义：首次内容渲染时间优化方案： 内联关键 CSS, 提取首屏样式内联到 &lt;style&gt; 标签 服务端渲染（SSR） 2.2 TTI (Time to Interactive)定义：页面完全可交互时间优化方案： 代码分割, 使用动态 import() 分割代码12// React 动态加载组件const HeavyComponent = React.lazy(() =&gt; import('./ HeavyComponent')); 预加载关键路由, 使用 Quicklink 预判用户行为12import quicklink from 'quicklink/dist/quicklink.mjs';quicklink(); 3.优化策略 缓存策略：设置 Cache-Control: max-age=31536000 对静态资源长期缓存 图片优化：使用 WebP 格式 + loading=”lazy” 属性 字体优化：使用 font-display: swap + 子集化(先显示后备字体，再交换) Service Worker：实现离线缓存和资源预取 HTTP/2：升级协议减少连接延迟","link":"/2023/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E6%A0%87/"},{"title":"离线环境部署sentry","text":"前置条件 已准备好无网络环境的 Linux 服务器 本地可联网的机器用于准备离线资源 可通过 内网传输工具 传输文件 一、本地机器操作1.1 下载 Sentry 官方仓库12git clone https://github.com/getsentry/self-hosted.gitcd self-hosted 1.2 获取所需 Docker 镜像12345678910111213141516 # 获取镜像列表（示例） docker pull postgres:14-alpine docker pull redis:6.2-alpine docker pull clickhouse/clickhouse-server:22.6 docker pull sentry:latest docker pull getsentry/snuba:latest docker pull getsentry/symbolicator:latest# 保存镜像为离线文件 docker save -o sentry-images.tar \\ postgres:14-alpine \\ redis:6.2-alpine \\ clickhouse/clickhouse-server:22.6 \\ sentry:latest \\ getsentry/snuba:latest \\ getsentry/symbolicator:latest 1.3 打包配置文件1234567891011121314151617181920212223242526tar czvf sentry-offline-pack.tar.gz \\ sentry-images.tar \\ self-hosted/``` #### 二、离线服务器操作##### 2.1 传输并解压文件```bash# 将 sentry-offline-pack.tar.gz 复制到服务器tar xzvf sentry-offline-pack.tar.gzcd self-hosted# 加载 Docker 镜像docker load -i ../sentry-images.tar``` ##### 2.2 修改 Docker Compose 配置```dockerfile# 修改 docker-compose.yml 中的镜像配置 services: postgres: image: postgres:14-alpine # 确保与本地镜像名一致 redis: image: redis:6.2-alpine clickhouse: image: clickhouse/clickhouse-server:22.6 sentry: image: sentry:latest 2.3 启动服务12345678# Sentry 需要写入权限的目录chmod -R 777 ./sentry-datachmod -R 777 ./postgres-data# 初始化数据库docker-compose run --rm sentry upgrade# 启动所有服务docker-compose up -d 三、启动报错3.1 报错 external volume sentry-kafka not found1234# 手动创建docker volume create sentry-kafka# 通过 ls 可以查看是否创建成功docker volumne ls 3.2 ClickHouse connection refused123456# 检查ClickHouse配置cat clickhouse-config.xml | grep listen_host# 应包含：&lt;listen_host&gt;0.0.0.0&lt;/listen_host&gt;# 验证端口访问nc -zv 127.0.0.1 9000 四、验证部署4.1 检查容器状态12345678docker-compose ps# 预期输出示例Name Command State Ports -------------------------------------------------------------------------sentry-web /entrypoint.sh run web ... Up 9000/tcpsentry-worker /entrypoint.sh run worker Uppostgres docker-entrypoint.sh postgres Up 5432/tcp 4.2 访问 Sentry 浏览器访问 http://&lt;服务器IP&gt;:9000，完成初始用户注册","link":"/2022/09/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2sentry/"}],"tags":[{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"h5","slug":"h5","link":"/tags/h5/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"webSocket","slug":"webSocket","link":"/tags/webSocket/"},{"name":"安全","slug":"安全","link":"/tags/%E5%AE%89%E5%85%A8/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"}],"pages":[]}